<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dota 2 Pick Assistant</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        .search { margin: 10px; padding: 5px; width: 80%; }
        .heroes { display: flex; flex-wrap: wrap; justify-content: center; }
        .hero { margin: 5px; padding: 10px; cursor: pointer; text-align: center; }
        .hero img { width: 50px; height: 50px; display: block; margin: auto; }
        .selected-heroes, .recommended-heroes { display: flex; flex-wrap: wrap; justify-content: center; margin-top: 10px; }
        .selected-hero, .recommended-hero { margin: 5px; text-align: center; }
        .selected-hero img, .recommended-hero img { width: 60px; height: 60px; border-radius: 10px; }
        .counterpicks { margin-top: 20px; font-weight: bold; color: green; }
    </style>
</head>
<body>
    <h2>Dota 2 Pick Assistant</h2>
    <input type="text" class="search" placeholder="Search hero..." oninput="filterHeroes()">
    <h3>Enemy Team:</h3>
    <div class="selected-heroes" id="selectedHeroes"></div>
    <h3>Available Heroes:</h3>
    <div class="heroes" id="heroList"></div>
    <h3>Recommended Picks:</h3>
    <div class="recommended-heroes" id="recommendedHeroes"></div>

    <script>
let allHeroes = [];
let selectedHeroes = [];
let counterpicks = {};
const imgBaseUrl = "https://cdn.cloudflare.steamstatic.com/apps/dota2/images/dota_react/heroes/";

async function fetchHeroes() {
    try {
        const response = await fetch("https://api.opendota.com/api/heroes");
        const data = await response.json();
        
        // Проверяем, что данные — это массив
        if (Array.isArray(data)) {
            allHeroes = data;
            console.log("Fetched heroes:", allHeroes); // Проверка данных
            await fetchCounterpicks();
            renderHeroes();
        } else {
            console.error("Expected an array of heroes, but got:", data);
        }
    } catch (error) {
        console.error("Error fetching heroes:", error);
    }
}

async function fetchCounterpicks() {
    try {
        // Ограничим количество запросов, чтобы избежать ошибки 429
        for (let i = 0; i < Math.min(allHeroes.length, 5); i++) { // Обрабатываем только первые 5 героев
            const hero = allHeroes[i];
            const response = await fetch(`https://api.opendota.com/api/heroes/${hero.id}/matchups`);
            const matchups = await response.json();
            
            counterpicks[hero.localized_name] = matchups
                .sort((a, b) => b.wins - a.wins) // Сортируем по количеству побед
                .slice(0, 5) // Берем топ-5 контрпиков
                .map(matchup => {
                    const counterHero = allHeroes.find(h => h.id === matchup.hero_id);
                    return counterHero ? counterHero.localized_name : null;
                })
                .filter(name => name !== null);
        }
        console.log("Fetched counterpicks:", counterpicks); // Проверка данных
    } catch (error) {
        console.error("Error fetching counterpicks:", error);
    }
}

function renderHeroes() {
    const heroList = document.getElementById("heroList");
    heroList.innerHTML = "";
    
    // Проверяем, что allHeroes — это массив
    if (Array.isArray(allHeroes)) {
        allHeroes.forEach(hero => {
            let div = document.createElement("div");
            div.className = "hero";
            div.innerHTML = `<img src='${imgBaseUrl + hero.name.replace("npc_dota_hero_", "")}.png' alt='${hero.localized_name}'><br>${hero.localized_name}`;
            div.onclick = () => selectHero(hero);
            heroList.appendChild(div);
        });
    } else {
        console.error("allHeroes is not an array:", allHeroes);
    }
}

function selectHero(hero) {
    if (selectedHeroes.length < 5 && !selectedHeroes.some(h => h.id === hero.id)) {
        selectedHeroes.push(hero);
        updateSelectedHeroes();
        updateRecommendedHeroes();
    }
}

function updateSelectedHeroes() {
    const selectedDiv = document.getElementById("selectedHeroes");
    selectedDiv.innerHTML = "";
    selectedHeroes.forEach(hero => {
        let div = document.createElement("div");
        div.className = "selected-hero";
        div.innerHTML = `<img src='${imgBaseUrl + hero.name.replace("npc_dota_hero_", "")}.png' alt='${hero.localized_name}'><br>${hero.localized_name}`;
        selectedDiv.appendChild(div);
    });
}

function updateRecommendedHeroes() {
    let recommendedSet = new Set();
    selectedHeroes.forEach(hero => {
        if (counterpicks[hero.localized_name]) {
            counterpicks[hero.localized_name].forEach(counter => recommendedSet.add(counter));
        }
    });
    const recommendedDiv = document.getElementById("recommendedHeroes");
    recommendedDiv.innerHTML = "";
    Array.from(recommendedSet).forEach(heroName => {
        let hero = allHeroes.find(h => h.localized_name === heroName);
        if (hero) {
            let div = document.createElement("div");
            div.className = "recommended-hero";
            div.innerHTML = `<img src='${imgBaseUrl + hero.name.replace("npc_dota_hero_", "")}.png' alt='${hero.localized_name}'><br>${hero.localized_name}`;
            recommendedDiv.appendChild(div);
        }
    });
}

function filterHeroes() {
    let search = document.querySelector(".search").value.toLowerCase();
    document.querySelectorAll(".hero").forEach(heroDiv => {
        heroDiv.style.display = heroDiv.textContent.toLowerCase().includes(search) ? "block" : "none";
    });
}

fetchHeroes();
fetchHeroes();
    </script>
</body>
</html>
